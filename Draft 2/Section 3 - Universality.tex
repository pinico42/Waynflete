\documentclass[Master.tex]{subfiles}

\begin{document}

\renewcommand{\arraystretch}{1.5}p
So far, we have explored how our two methods of computation can perform many common operations, including data manipulation \& storage, on top of looping and conditional branching. Unfortunatley, it is too vague to simply define a 'comuputer' as a system which can perform a somewhat arbitrary set of operations - we must refine this to a simple set of functions. The easiest way of doing this is by assuming that a certain system can perform every operation a computer can perform. For this purpose, we will choose Turing machines, for purposes that will become clear later. Now, in order to prove that any system is a 'computer', we must simply prove that it can perform any operation a Turing machine can perform - in essence, it must be able to fully emulate the operation of a Turing FSM. 

 This essentially means that a machine, given a specific Turing machine starting configuration, should be able to produce every consecutive following state (i.e. it takes an FSM description table as input, and generates an infinite sequence of following tape \& \textit{m}-configuration states). Any machine that can do this shall be called a \textit{Universal Machine}.

\subsection{Standard Turing Description Form}

First, we must define what we actually mean by a description table - we shall do this by describing a standard form for these tables. Looking at the first table described, we can see that any sequence described in the operations section of the table follows a similar format: E; [E, R]; [E, L]; P\textit{a}; [ P\textit{a}, R]; [ P\textit{a}, L] or no entry at all. A more complex set of operations such as those found in later tables can always be put into one of these forms through the addition of intermediary \textit{m}-configurations which are called in sequence.

Next, let us rename the \textit{m}-configurations as $q_0$, $q_1$, $q_2$, $...$, $q_n$ for clarity (the initial \textit{m}-configuration shall always be called $q_0$, the second $q_1$ and so on). Furthermore, the symbols shall be renamed $S_0$, $S_1$, $S_2$, $...$, $S_n$ - in this case, $S_0$ will represent the blank square, $S_1$ will represent \texttt{0} and $S_2$ will represent \texttt{1}. The movement transformations L and R will be renamed $M_L$, $M_R$, and the operation to keep the tape stationary is simply $M_S$. Our tables are now of form:

\medskip\noindent\begin{tabu} to \textwidth{XXXX}
    \multicolumn{2}{c}{\textit{Configuration}} & \multicolumn{2}{c}{\textit{Behavior}} \\
    \textit{m-config} & \textit{symbol} & \textit{operations} & \textit{final m-config} \\
    \hhline{====}
    $q_i$ & $S_i$ & P$S_k$, $M_{L/R/S}$ & $q_m$ \\
    \hhline{----}
\end{tabu}

\medskip

Lines such as 

\medskip\noindent\begin{tabu} to \textwidth{XXXX}
    $q_i$ & $S_i$ & E, $M_{L/R/S}$ & $q_m$ \\
\end{tabu}
\medskip
are to be written as

\medskip\noindent\begin{tabu} to \textwidth{XXXX}
    $q_i$ & $S_i$ & P$S_0$, $M_{L/R/S}$ & $q_m$ \\
\end{tabu}
\medskip
and lines such as 

\medskip\noindent\begin{tabu} to \textwidth{XXXX}
    $q_i$ & $S_i$ & $M_{L/R/S}$ & $q_m$ \\
\end{tabu}
\medskip
are to be written as

\medskip\noindent\begin{tabu} to \textwidth{XXXX}
    $q_i$ & $S_i$ & P$S_i$, $M_{L/R/S}$ & $q_m$ \\
\end{tabu}
\medskip
in order for all lines to be written in the first format. As the number of symbols used for a machine is always finite as the number of states is finite, it is possible to enumerate under every single \textit{m}-configuration an action for every single symbol $S_i$ that the machine coud be reading. In this way, "All" and "Not \textit{a}" will be portrayed in this format as the enumerated behaviours for every relevant symbol. This idea also allows the last simplification shown in the table above to work.

This expanded and generalised configuration is much more helpful to us, as while any Turing machine configuration (including using \textit{m}-functions) can be written in this format, it is very concise and regular. This allows it to be given as input to our universal machines.

\subsection{Universality in the $\lambda$-calculus}
Firstly, we shall prove that $\lambda$-calculus is Turing complete by building a universal machine using only $\lambda$-functions. The core of the machine will be a function which calculates a single step in the FSM's calculation: It will receive as its parameters the current state of the tape and the current \textit{m}-configuration. As this function will be unique to the specific FSM that is being emulated, the entire behavior of the machine based on this configuration (i.e. the machine's table) shall be contained within this function. The function will then be applied to itself repeatedly to produce the sequences of states.

\subsubsection{Emulating the Tape}\label{sec:LambdaUnivTape}
In order to achieve this, we must define certain new objects in $\lambda$-calculus. First of all, ordered lists - these will be used to describe the current content of the tape. These are defined as a sequence of nodes, where each node is a pair with the first element as the content of the node and the second element is the next node in the sequence. The final node will have \textbf{0} as its first element to signify the end of the list - the second element will never be referred to; as such \textbf{0} will be used as a placeholder (of course this only works if the list is not designed to contain any values of zero or true, as they will be indistinguishable from the end marker - I shall use \textbf{1} to represent $S_0$, \textbf{2} to represent $S_1$ and so on). For example, the list [a,b,c,d,e] would be represented as:
\begin{equation*}
\lambda l.la(\lambda m.mb(\lambda n.nc(\lambda o.od(\lambda p.pe(\lambda z.z\bm{\mathrm{00}})))))
\end{equation*}
In order to obtain the first element (head), the argument \textbf{T} would be applied to the list; to get the remaining elements (tail) the \textbf{F} argument would be applied. 
Furthermore, to prepend an element to the start of a list:
\begin{equation*}
\bm{\mathrm{:}} = \lambda xlf.f[x][l]
\end{equation*}
This takes an element to prepend $x$, and a list $l$, and constructs a new pair with the given element as the first element and the original list as the second.
 
The tape of the FSM extends infinitely in both directions either side of the cursor. We shall represent this as a pair of lists, $T_p$ as the list of all the predecessors to the cursor and $T_s$ as the list of all the successors to the cursor. The predecessors shall be listed in reverse order, such that the head of $T_p$ is the symbol directly to the left of the cursor. The head of $T_s$ is the symbol considered to be `under' the cursor, the next element is the symbol to the right of that, and so on. These tapes will begin as a single node, and as the machine requires further squares in either direction further nodes will be added.
\begin{equation*}
T_a = \lambda f.f T_p T_s
\end{equation*}

\subsubsection{Movement Operations}
To emulate cursor movement, we will create transformation functions for the tape. These functions will shift the tape by moving the head of $T_s$ to the head of $T_p$ or vice versa.

\begin{gather*}
\begin{aligned}
\bm{M}_L &= \lambda t_a f.f [(t_a\bm{\mathrm{T}})\bm{\mathrm{F}}] [\bm{\mathrm{:}}([t_a\bm{\mathrm{T}}]\bm{\mathrm{T}})(t_a\bm{\mathrm{F}})]\\
\bm{M}_R &= \lambda t_a f.f [\bm{\mathrm{:}}([t_a\bm{\mathrm{F}}]\bm{\mathrm{T}})(t_a\bm{\mathrm{T}})] [(t_a\bm{\mathrm{F}})\bm{\mathrm{F}}]\\
\bm{M}_S &= \lambda x.x\\
\end{aligned}
\end{gather*}
The $\bm{M}_L$ function produces a new tape pair, after taking the original tape pair as parameter $t_a$. The first element of this new pair is simply the tail of $T_p$ ($T_p$ being found at $T_a\bm{\mathrm{T}})$. The second element is the head of $T_p$ prepended to the entirety of $T_s$ (found at $T_a\bm{\mathrm{T}})$. $\bm{M}_R$ will do the effective opposite, prepending the head of $T_s$ to $T_p$ and producing the tail of $T_s$. $\bm{M}_S$ Will keep the tape in its current state.

\subsubsection{Infinite-Length Tape}

Unfortunately, the tape which we are currently dealing with is unlike that of a Turing machine, due to the fact that it is of finite length - we cannot write a single list in $\lambda$-calculus which expresses the entire tape. As such, when the machine moves left or right onto the node with \textbf{0} as the head signifying the end of the list, we will replace it with a node containing the blank square symbol $S_0$, represented by a \textbf{1}, as the head, and another end marker node as he tail. To do this, we will have another transformation function which will check if either head element of the tape pair is \textbf{0}, and if so, will replace it with an empty square node $\bm{\epsilon}$ - otherwise it will simply be replaced with the original head:

\begin{gather*}
\begin{aligned}
\bm{\epsilon} &= \lambda g.g[\bm{\textbf{1}}][\lambda d.d\bm{\mathrm{0}}\bm{\mathrm{0}}] \\
\bm{C} &= \lambda t_a g.g[\bm{\mathrm{Z}}(t_a\bm{\mathrm{T}}\bm{\mathrm{T}})(\bm{\epsilon})(t_a\bm{\mathrm{T}}\bm{\mathrm{T}})][\bm{\mathrm{Z}}(t_a\bm{\mathrm{F}}\bm{\mathrm{T}})(\bm{\epsilon})(t_a\bm{\mathrm{F}}\bm{\mathrm{T}})]
\end{aligned}
\end{gather*}
This transformation will be applied after every tape movement operation.

\subsubsection{Printing to the Tape}

The transformation that writes a given real number to the square beneath the cursor is not particularly complex - it simply replaces the current head of $T_s$ with a successor.

\begin{equation*}
\bm{W} = \lambda a t_a p.p[t_a\bm{\mathrm{T}}][\lambda d.d(a)(t_a\bm{\mathrm{FF}})]
\end{equation*}

\subsubsection{Storing \& Accessing \textit{m}-configurations}
%\subsubsubwithchickenandmayopleasethanks{eating & fulfilling life goals #subwaydatesboiiiiis love man chllz peace wavey donss}
Once again, in order to store the information and operations associated with each \textit{m}-configuration, we shall use another list. The first element of the list shall represent $q_0$, the second $q_1$ and so on.
Each element of the list will be a list in itself. Each element of this list shall refer to the symbol aspect of the configuration. These elements are pairs: the first element being the symbol to be found (a real number), the second being the action to be performed under this configuration.

The action itself will be yet another pair. The first element is the transformation that should be performed on the tape - this transformation will be of the form $(\bm{C})(\bm{M}_{L/R/S})(\bm{W}a)$, which applies first a write transformation before a movement transformation and the tape length correction transformation. The second element is a function which, when given the description of the machine, finds the given \textit{m}-configuration. We shall note these m-configuration references as shown, with the example of the reference to $q_3$:
\begin{equation*}
\bm{Q}_3 = \lambda l.l\bm{\textbf{FFFT}}
\end{equation*}
This gets the fourth head of the given list, which refers to $q_3$.

%As an example, here is the description for the first machine described, which generates the sequence \texttt{01010101...} (for simplicity, this version does not leave \textit{s}-squares blank). For reference, here is the enumerated table:
%\medskip\noindent\begin{tabu} to \textwidth{XXXX}
%    \multicolumn{2}{c}{\textit{Configuration}} & \multicolumn{2}{c}{\textit{Behavior}} \\
%    \textit{m-config} & \textit{symbol} & \textit{operations} & \textit{final m-config} \\
%    \hhline{====}
%    $q_0$ & $S_0$ & PS_1       & $\mathbb{A}$ \\
%    $q_0$ & $S_1$ & PS_2 & $\mathbb{A}$ \\ 
%    $q_0$ & \texttt{1}    & R, R, P\texttt{0} & $\mathbb{A}$ \\ 
%\end{tabu}
%We shall represent this table as such:
%\begin{gather*}
%\begin{aligned}
%\bm{d}
%\end{aligned}
%\end{gather*}

%[I cba to do this now]

In order to find which action should be performed given a certain configuration, we shall use the following function which produces a pair of a list transformation and an \textit{m}-config reference from a current \textit{m}-config, the current symbol, and the description function. As part of this function, the recursive function $\bm{\rho}$ must be used in conjunction with the \textbf{Y} combinator, which returns the action aspect of the first pair under symbol $s$ in list $l$ (the $r$ argument is the argument which would represent the function as a whole, and is recursively called by the \textbf{Y} combinator)

\begin{gather*}
\begin{aligned}
\bm{\rho} &= \lambda rls.(\bm{\doteq}(l\bm{\mathrm{TT}})s)(l\bm{\mathrm{TF}})(r(l\bm{\mathrm{F}})s)\\
\bm{I} &= \lambda qsd.\bm{\mathrm{Y}\rho}(qd)s
\end{aligned}
\end{gather*}

\subsubsection{Universal Machine State Change Operation}

At last, we can involve all of these functions to create a single operation which transforms a given machine configuration (\textit{m}-config, $T_p$ \& $T_s$, and the description table) into the machine configuration for the next state. This configuration shall be represented as a pair, the first element being a pair of the \textit{m}-config reference and the tape, and the second element as the description table. The $\bm{\nu}$ function gets the action function from the given machine configuration.

\begin{gather*}
\begin{aligned}
\bm{\nu} &= \lambda c.\bm{I}(c\bm{\mathrm{TT}})([c\bm{\mathrm{TF}}]\bm{\mathrm{FT}})(c\bm{\mathrm{F}})\\
\bm{X} &= \lambda cf.f[\lambda g.g[(\bm{\nu}c)\bm{\mathrm{F}}][((\bm{\nu}c)\bm{\mathrm{T}})(c\bm{\mathrm{TF}})]]c
\end{aligned}
\end{gather*}

\subsubsection{Universal Machine State Generator}

Finally, we shall define a recursive function which produces every consecutive state by running $\bm{X}$ on itself an infinite number of times.

\begin{gather*}
\begin{aligned}
\bm{\omega} &= \lambda uc.u(\bm{X}c) \\
\bm{U} &= \lambda c.\bm{\mathrm{Y}}\bm{\omega}c
\end{aligned}
\end{gather*}

\end{document}