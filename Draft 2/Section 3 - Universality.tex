\documentclass[Master.tex]{subfiles}

\begin{document}

\renewcommand{\arraystretch}{1.5}
So far, we have explored how our two methods of computation can perform many common operations, including data manipulation \& storage, on top of looping and conditional branching. Unfortunately, it is too vague to simply define a 'comuputer' as a system which can perform a somewhat arbitrary set of operations - we must refine this to a simple set of functions. The easiest way of doing this is by assuming that a certain system can perform every operation a computer can perform. For this purpose, we have chosen Turing machines, due to the fact that they are easy to realise physically. Now, in order to prove that any system is a 'computer', we must simply prove that it can perform any operation a Turing machine can perform - in essence, it must be able to fully emulate the operation of a Turing machine. 

 This essentially means that a machine, given a specific Turing machine starting configuration, should be able to produce every consecutive following state (i.e. it takes a machine's description table as input, and generates an infinite sequence of the following tape configurations \& the corresponding finishing state for that step). Any machine that can do this shall be called a \textit{Universal Machine}.

\subsection{Standard Turing Description Form}

First, we must define what we actually mean by a description table - we shall do this by describing a standard form for these tables, as shown by Turing in \cite{turing1936computablenumbers}. Looking at the first table described, we can see that any transition function follows a similar format: E; [E, R]; [E, L]; P\textit{a}; [ P\textit{a}, R]; [ P\textit{a}, L] or no entry at all. More complex transition functions such as those found in later tables can always be put into one of these forms through the addition of intermediary states which are called in sequence.

Next, let us rename the states as $q_0$, $q_1$, $q_2$, $...$, $q_n$ for clarity (the initial state shall always be called $q_0$, the second $q_1$ and so on). Furthermore, the symbols shall be renamed $S_0$, $S_1$, $S_2$, $...$, $S_n$ - in this case, $S_0$ will represent the blank square, $S_1$ will represent \texttt{0} and $S_2$ will represent \texttt{1}. The movement operations L and R will be renamed $M_L$, $M_R$, and the operation to keep the tape stationary is simply $M_S$. Our tables are now of form:

\medskip\noindent\begin{tabu} to \textwidth{XXXX}
    \multicolumn{2}{c}{\textit{Configuration}} & \multicolumn{2}{c}{\textit{Behavior}} \\
    \textit{state} & \textit{symbol} & \textit{transition function} & \textit{final state} \\
    \hhline{====}
    $q_i$ & $S_i$ & P$S_k$, $M_{L/R/S}$ & $q_m$ \\
    \hhline{----}
\end{tabu}

\medskip

Lines such as 

\medskip\noindent\begin{tabu} to \textwidth{XXXX}
    $q_i$ & $S_i$ & E, $M_{L/R/S}$ & $q_m$ \\
\end{tabu}
\medskip
are to be written as

\medskip\noindent\begin{tabu} to \textwidth{XXXX}
    $q_i$ & $S_i$ & P$S_0$, $M_{L/R/S}$ & $q_m$ \\
\end{tabu}
\medskip
and lines such as 

\medskip\noindent\begin{tabu} to \textwidth{XXXX}
    $q_i$ & $S_i$ & $M_{L/R/S}$ & $q_m$ \\
\end{tabu}
\medskip
are to be written as

\medskip\noindent\begin{tabu} to \textwidth{XXXX}
    $q_i$ & $S_i$ & P$S_i$, $M_{L/R/S}$ & $q_m$ \\
\end{tabu}
\medskip
in order for all lines to be written in the first format. As the number of symbols used for a machine is always finite, it is possible to enumerate under every single state an action for every single symbol $S_i$ that the machine could be reading. In this way, "All" and "Not \textit{a}" will be portrayed in this format as the enumerated behaviours for every relevant symbol. This idea also allows the last simplification shown in the table above to work.

This expanded and generalised configuration is much more helpful to us, as while any Turing machine configuration (including using \textit{m}-functions) can be written in this format, it is very concise and regular. This allows it to be given as input to our universal machines.

\subsection{Universality in the $\lambda$-calculus}
Firstly, we shall prove that $\lambda$-calculus is Turing complete by building a universal machine using only $\lambda$-functions. The core of the machine will be a function which calculates a single step in the Turing machine's calculation: It will receive as its parameters the current configuration of the tape and the current state. As this function will be unique to the specific machine that is being emulated, the entire behaviour of the machine based on this configuration (i.e. the machine's table) shall be contained within this function. The function will then be applied to itself repeatedly to produce the sequences of states.

\subsubsection{Emulating the Tape}\label{sec:LambdaUnivTape}
In order to achieve this, we must define certain new objects in $\lambda$-calculus. First of all, ordered lists - these will be used to describe the current content of the tape. These are defined as a sequence of nodes, where each node is a pair with the first element as the content of the node and the second element is the next node in the sequence (as shown in \cite{tromp2007binary}). The final node will have \textbf{0} as its first element to signify the end of the list - the second element will never be referred to; as such \textbf{0} will be used as a placeholder (of course this only works if the list is not designed to contain any values of zero or true, as they will be indistinguishable from the end marker - I shall use \textbf{1} to represent $S_0$, \textbf{2} to represent $S_1$ and so on). For example, the list [a,b,c,d,e] would be represented as:
\begin{equation*}
\lambda l.la(\lambda m.mb(\lambda n.nc(\lambda o.od(\lambda p.pe(\lambda z.z\bm{\mathrm{00}})))))
\end{equation*}
In order to obtain the first element (head), the argument \textbf{T} would be applied to the list; to get the remaining elements (tail) the \textbf{F} argument would be applied. 
Furthermore, to prepend an element to the start of a list:
\begin{equation*}
\bm{\mathrm{:}} = \lambda xlf.f[x][l]
\end{equation*}
This takes an element to prepend $x$, and a list $l$, and constructs a new pair with the given element as the first element and the original list as the second.
 
The tape of the machine extends infinitely in both directions either side of the cursor. We shall represent this as a pair of lists: $T_p$ as the list of all the predecessors to the cursor and $T_s$ as the list of all the successors to the cursor. The predecessors shall be listed in reverse order, such that the head of $T_p$ is the symbol directly to the left of the cursor. The head of $T_s$ is the symbol considered to be `under' the cursor, the next element is the symbol to the right of that, and so on. These tapes will begin as a single node, and as the machine requires further squares in either direction further nodes will be added.
\begin{equation*}
T_a = \lambda f.f T_p T_s
\end{equation*}

\subsubsection{Movement Operations}
To emulate cursor movement, we will create transformation functions for the tape. These operations will shift the tape by moving the head of $T_s$ to the head of $T_p$ or vice versa.

\begin{gather*}
\begin{aligned}
\bm{M}_L &= \lambda t_a f.f [(t_a\bm{\mathrm{T}})\bm{\mathrm{F}}] [\bm{\mathrm{:}}([t_a\bm{\mathrm{T}}]\bm{\mathrm{T}})(t_a\bm{\mathrm{F}})]\\
\bm{M}_R &= \lambda t_a f.f [\bm{\mathrm{:}}([t_a\bm{\mathrm{F}}]\bm{\mathrm{T}})(t_a\bm{\mathrm{T}})] [(t_a\bm{\mathrm{F}})\bm{\mathrm{F}}]\\
\bm{M}_S &= \lambda t_a.t_a\\
\end{aligned}
\end{gather*}
The $\bm{M}_L$ function produces a new tape pair, after taking the original tape pair as parameter $t_a$. The first element of this new pair is simply the tail of $T_p$ ($T_p$ being found at $T_a\bm{\mathrm{T}})$. The second element is the head of $T_p$ prepended to the entirety of $T_s$ (found at $T_a\bm{\mathrm{T}})$. $\bm{M}_R$ will do the effective opposite, prepending the head of $T_s$ to $T_p$ and producing the tail of $T_s$. $\bm{M}_S$ Will keep the tape in its current state.

\subsubsection{Infinite-Length Tape}

Unfortunately, the tape which we are currently dealing with is unlike that of a Turing machine, due to the fact that it is of finite length - we cannot write a single list in $\lambda$-calculus which expresses the entire tape. As such, when the machine moves left or right onto the node with \textbf{0} as the head signifying the end of the list, we will replace it with a node containing the blank square symbol $S_0$, represented by a \textbf{1}, as the head, and another end marker node as the tail. To do this, we will have another transformation function which will check if either head element of the tape pair is \textbf{0}, and if so, will replace it with an empty square node $\bm{\epsilon}$ - otherwise it will simply be replaced with the original head:

\begin{gather*}
\begin{aligned}
\bm{\epsilon} &= \lambda g.g[\bm{\textbf{1}}][\lambda d.d\bm{\mathrm{0}}\bm{\mathrm{0}}] \\
\bm{C} &= \lambda t_a g.g[\bm{\mathrm{Z}}(t_a\bm{\mathrm{T}}\bm{\mathrm{T}})(\bm{\epsilon})(t_a\bm{\mathrm{T}}\bm{\mathrm{T}})][\bm{\mathrm{Z}}(t_a\bm{\mathrm{F}}\bm{\mathrm{T}})(\bm{\epsilon})(t_a\bm {\mathrm{F}}\bm{\mathrm{T}})]
\end{aligned}
\end{gather*}
This transformation will be applied after every tape movement operation.

\subsubsection{Printing to the Tape}

The operation function that writes a given symbol to the square beneath the cursor is not a particularly complex transformation - it simply replaces the current head of $T_s$ with the given numeral $a$.

\begin{equation*}
\bm{W} = \lambda a t_a p.p[t_a\bm{\mathrm{T}}][\mathrm{\bm{:}} a (t_a \bm{\mathrm{FF}})]
\end{equation*}

\subsubsection{Storing \& Accessing states}
%\subsubsubwithchickenandmayopleasethanks{eating & fulfilling life goals #subwaydatesboiiiiis love man chllz peace wavey donss}
Once again, in order to store the symbol, transition function and final state associated with each states, we shall use a list. The first element of the list shall represent $q_0$, the second $q_1$ and so on.
Each element of the list will be a list in itself. Each element of this nested list shall refer to a single line described by the symbol aspect of the configuration. These elements are pairs: the first element being the symbol to be found (a numeral), the second being the action to be performed under this configuration.

The action itself will be yet another pair. The first element is the transition function that should be executed on the tape - this will be of the form $(\bm{C})(\bm{M}_{L/R/S})(\bm{W}a)$, which applies first a write operation before a movement operation and the tape length correction operation. The second element is a function which, when given the description of the machine, finds the given state. We shall note these m-configuration references as shown, with the example of the reference to $q_3$:
\begin{equation*}
\bm{Q}_3 = \lambda l.l\bm{\textbf{FFFT}}
\end{equation*}
This gets the fourth head of the given list, which refers to $q_3$.

%As an example, here is the description for the first machine described, which generates the sequence \texttt{01010101...} (for simplicity, this version does not leave \textit{s}-squares blank). For reference, here is the enumerated table:
%\medskip\noindent\begin{tabu} to \textwidth{XXXX}
%    \multicolumn{2}{c}{\textit{Configuration}} & \multicolumn{2}{c}{\textit{Behavior}} \\
%    \textit{m-config} & \textit{symbol} & \textit{operations} & \textit{final m-config} \\
%    \hhline{====}
%    $q_0$ & $S_0$ & PS_1       & $\mathbb{A}$ \\
%    $q_0$ & $S_1$ & PS_2 & $\mathbb{A}$ \\ 
%    $q_0$ & \texttt{1}    & R, R, P\texttt{0} & $\mathbb{A}$ \\ 
%\end{tabu}
%We shall represent this table as such:
%\begin{gather*}
%\begin{aligned}
%\bm{d}
%\end{aligned}
%\end{gather*}

%[I cba to do this now]

In order to find which action should be performed given a certain configuration, we shall use the following function which produces a pair of a list transition function and an state reference from a current state, the current symbol, and the description function. As part of this function, the recursive function $\bm{\rho}$ must be used in conjunction with the \textbf{Y} combinator, which returns the action aspect of the first pair under symbol $s$ in list $l$ (the $r$ argument is the argument which would represent the function as a whole, and is recursively called by the \textbf{Y} combinator)

\begin{gather*}
\begin{aligned}
\bm{\rho} &= \lambda rls.(\bm{\doteq}(l\bm{\mathrm{TT}})s)(l\bm{\mathrm{TF}})(r(l\bm{\mathrm{F}})s)\\
\bm{I} &= \lambda qsd.\bm{\mathrm{Y}\rho}(qd)s
\end{aligned}
\end{gather*}

\subsubsection{Universal Machine State Change Operation}

At last, we can involve all of these functions to create a single operation which transforms a given machine configuration (state, $T_p$ \& $T_s$, and the description table) into the machine configuration for the next state. This configuration shall be represented as a pair, the first element being a pair of the state reference and the tape, and the second element as the description table. The $\bm{\nu}$ function gets the action function from the given machine configuration.

\begin{gather*}
\begin{aligned}
\bm{\nu} &= \lambda c.\bm{I}(c\bm{\mathrm{TT}})([c\bm{\mathrm{TF}}]\bm{\mathrm{FT}})(c\bm{\mathrm{F}})\\
\bm{X} &= \lambda cf.f[\lambda g.g[(\bm{\nu}c)\bm{\mathrm{F}}][((\bm{\nu}c)\bm{\mathrm{T}})(c\bm{\mathrm{TF}})]]c
\end{aligned}
\end{gather*}

\subsubsection{Universal Machine State Generator}

Finally, we shall define a recursive function which produces every consecutive state by running $\bm{X}$ on itself repeatedly. When this is evaluated, each iteration of the machine shall be passed into the \textbf{Y} combinator, leading to each consecutive state being found during evaluation.

\begin{gather*}
\begin{aligned}
\bm{\omega} &= \lambda uc.u(\bm{X}c) \\
\bm{U} &= \lambda c.\bm{\mathrm{Y}}\bm{\omega}c
\end{aligned}
\end{gather*}

\subsection{Conclusion}

We have successfully shown here that $\lambda$-calculus is a Universal, Turing-complete language - it is able to perform every action that a Turing Machine can perform, and as such is at least as powerful as Turing's method of computation. Furthermore - and this the reader must take on faith, or rely on intuition - it is possible for a Turing machine to simulate $\lambda$-calculus; Turing machines are Effectively Calculable, and are at least as powerful as the $\lambda$-calculus. Therefore, these two methods of computation - one based in physical ideas, one based in conceptual ideas, are totally equivalent. Intuitively, it is clear that both use similar logical processes, similar to the workings of the logical aspect of human thought, and as such this result is unsurprising. However, what is truly remarkable is that what appears to be a Platonic reality of the concept of computability has been stumbled upon by two different methods designed independently of each other. This strengthens the idea of computability as defined this way, and gives us a very solid foundation from which to base our exploration of physical machines.

\end{document}