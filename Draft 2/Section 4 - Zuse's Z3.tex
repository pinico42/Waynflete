\documentclass[Master.tex]{subfiles}

\begin{document}

At this point, we have an almost complete definition of 'computer' - a machine which is able to fully implement the concept of effective computability. This can be done most simply through the implementation of an effectively computable method of computation, such as Turing Machines. However, in order to address the question of whether this was achieved during WW1 we must apply this test to the physical instruments created within this time.

\textit{TODO: Colossus}

\textit{TODO: Context of Z3}

\subsection{The Architecture of the Z3}

In this section I shall give a broad functional overview of the Z3. I shall explore primarily the function and usage of the machine, the aspects that would be visible to the programmer. I shall not go into detail about the operation of the machine itself unless it directly influences the machine's usage. The description of the machine was derived from \cite{rojas1997z3architecture}.

The Z3 was primarily purposed towards performing simple arithmetical calculations - addition, subtraction, multiplication, division, and the square root operation. The operands would be read from memory or from input from a keyboard, and the results would be written to memory or shown on a display. Programs would be written as sequences of 8-bit instructions on punched tape, and would be performed as they are read by the machine.

\subsubsection{Data Storage}



\subsubsection{Programming Model}

The instruction set for the Z3 consisted of three types of operation - I/O, memory and arithmetic. These instructions would be performed with respect to two floating-point registers, $R_1$ and $R_2$, which act as the two arguments for any arithmetical operation, and could be written to and read from by the non-arithmetical operations. 

The two memory instructions, \textbf{Pr} \textit{z} and \textbf{Ps} \textit{z}, load and store respectively the value of registers from and to memory. Pr \textit{z} will transfer the data stored at address \textit{z} to $R_1$ if it is clear, otherwise it will be written to $R_2$, overwriting any previous data. \textbf{Ps} \textit{z} transfers the value of $R_1$ only to address \textit{z}, and clears both $R_1$ and $R_2$ (such that the next \textbf{Pr} \textit{z} operation will write to $R_1$). 

The I/O instructions \textbf{Lu} and \textbf{Ld} respectively store and output values to and from $R_1$. \textbf{Lu} halts the machine and stores keyboard input in $R_1$ (clearing $R_2$), while \textbf{Ld} halts the machine and displays $R_1$ on an array of lamps, clearing both registers. Both operations require the machine to be restarted in order to continue execution, allowing time for the programmer to input data or write down output.

The arithmetical operations perform as follows:
\begin{gather*}
\begin{aligned}
&Ls_1:\quad	&R_1 &= R_1 \times R_2 \\
&Ls_2:\quad	&R_1 &= R_1 \div R_2 \\
&Lm:\quad	&R_1 &= R_1 + R_2 \\
&Li:\quad	&R_1 &= R_1 - R_2 \\
&Lw:\quad	&R_1 &= \sqrt{R_1} \\
\end{aligned}
\end{gather*}
For each operation, the 
\subsection{Universality in the Z3}

The first thing that must be considered when looking for universality in a potentially Turing-complete machine is the fact that, by the strict definition of a Turing machine, it must require infinite memory due to the nature of its tape. Unfortunately, this is impossible in the physical world as memory is always finite. As such, we must revise our definition of Turing-completeness to require only a finite tape.

At first glance, it is unclear that the Z3 can be made into a universal machine due to the fact that it allows for neither conditional branching\footnote{The ability to perform different operations depending on the state of a stored value} nor indirect addressing\footnote{The ability to refer to values stored in memory when the address of that memory is not specifically referred to in the program but is rather obtained from the value of some variable currently in memory}. However, through use of the tool available to the programmer these features can be emulated, and a Turing Machine can be simulated.

\subsubsection{Conditional Branching}

Firstly and fundamentally we shall construct conditional branches using a technique shown in \cite{ibarra1983intdivision} \textit{TODO: Check this ref} which allows the implementation of a form of case statement as found in modern programming languages such as JavaScript. Such an operation performs one of a set of different operations depending on the value of a given variable.

Given a positive integer variable $z$, the variable on which the outcome of the statement depends and the set of operations to be performed depending on the value of $z$, $P_1, ... , P_n$, we can produce a sequence of operations that will allow only the operation $P_z$ to perform. Due to the nature of the Z3 requiring a full sequence of commands to be executed without exception, every one of these operations will be evaluated; however, only operation $P_z$ will be allowed to actually affect memory.


At the start of the switch statement, a sequence of commands check if $z = j$ - if so the flag variable $t$ is set to $0$ (otherwise it is set to $1$). Next, for each operation $P_j$ (which will be of the form $a = b\ \{op\}\ c$), we will write in the program a sequence of commands that, if $t$ is $0$, write the value of $b\ \{op\}\ c$ to $a$. These statements are shown below:

\begin{gather*}
\begin{aligned}
u &= b\ \{op\}\ c \\
v &= a \cdot t \\
w &= 1 - t \\
u &= w \cdot u \\
a &= v + u
\end{aligned}
\end{gather*}

Or, for clarity, $a = (a \cdot t) + (1 - t)(b\ \{op\}\ c)$. If $t = 1$, $v$ is set to $t$; otherwise it is set to $0$. Furthermore, if $t = 0$, $u$ is set to the outcome of the operation; otherwise it is set to $0$ again. Therefore, if $t = 0$, $a$ is set to the outcome of the operation; otherwise it is set back to its original value. As such, after this transformation has been put in place for every $P$ operation, and a method to set $t$ at the start of the case statement has been implemented, every new command in this program can be executed - most superfluously - in order to only use the $z$-th command. Next we must produce a set of operations that will perform the computation
\begin{equation*}
\mathrm{if\ (}z = i\mathrm{)\ then\ } t = 0 \mathrm{\ else\ } t = 1
\end{equation*}

This is done using the following piece of code, where $e$ has been pre-set to a value much less than 1 (e.g. 1/1000).

\begin{gather*}
\begin{aligned}
d &= z - i \\
d &= d \cdot d \\
f &= d - e \\
g &= d\ /\ f \\ \\
t &= (2^{16} + g) - 2^{16} \\
\end{aligned}
\end{gather*}

The variable $d$ is only zero if $z = i$. If not, $d$ is set to a positive value, and $g$ is set to the ratio of $d$ and a value slightly smaller than $d$ - $1$ plus a small fractional part.

\subsubsection{Indirect Addressing}

\subsubsection{State Storage \& Access}

\end{document}
